#### 介绍
java

##### 并发编程模型分类

1:  线程之间如何通信及线程之间如何同步

    共享内存和消息传递

2:  并发模型
    
    共享内存: 线程之间共享程序的公共状态，线程之间通过写 – 读内存中的公共状态来隐式进行通信
    消息传递: 消息传递的并发模型里，线程之间没有公共状态，线程之间必须通过明确的发送消息来显式进行通信
    
3:  重排序

    1. 编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。
    2. 指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-Level Parallelism， ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。
    3. 内存系统的重排序。由于处理器使用缓存和读 / 写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。

4:  happens-before

    1. 程序顺序规则：一个线程中的每个操作，happens- before 于该线程中的任意后续操作。
    2. 监视器锁规则：对一个监视器锁的解锁，happens- before 于随后对这个监视器锁的加锁。
    3. volatile 变量规则：对一个 volatile 域的写，happens- before 于任意后续对这个 volatile 域的读。
    4. 传递性：如果 A happens- before B，且 B happens- before C，那么 A happens- before C。

运行时数据区域

    程序计数器      是一块较小的内存空间，可以看作是当前线程所执行字节码的行号指示器
    Java虚拟机栈   Java 方法执行的内存模型：每个方法被执行的时候都会创建一个栈帧（Stack Frame）用于存储
    本地方法栈      为虚拟机使用到的 Native 方法服务
    Java堆       在虚拟机启动时创建，被所有线程共享。作用是存放对象实例
    方法区 

    程序计数器 Java虚拟机栈 本地方法栈  是线程私有，随着线程启动，结束而 建立和销毁
    java堆和方法区 是线程共享，随着虚拟机启动而存在

垃圾回收算法

    标记-清除算法（mark-sweep）
    复制算法（copying）
    标记-整理算法（mark-compact）
    分代收集算法（generationa collection）

类加载机制

    虚拟机把class文件加载到内存，对数据校验，解析。初始化。形成虚拟机可使用的Java类型
    加载、验证、准备、解析、初始化、使用、卸载。其中验证、准备、解析三个阶段统称为连接
    
类加载器 双亲委派模型
    
    （自定义类加载器1，自定义类加载器2）--》（应用程序类加载器）--》（扩展类加载器）--》（启动类加载器）
    如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器完成。
    每个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，
    只有到父加载器反馈自己无法完成这个加载请求（它的搜索范围没有找到所需的类）时，子加载器才会尝试自己去加载
优点 

    Java类随着它的类加载器一起具备了一种带优先级的层次关系。比如java.lang.Object，
    它存放在rt.jar中，无论哪个类加载器要加载这个类，最终都是委派给启动类加载器进行加载，
    因此Object类在程序的各个类加载器环境中，都是同一个类。如果没有使用双亲委派模型，
    让各个类加载器自己去加载，那么Java类型体系中最基础的行为也得不到保障，应用程序会变得一片混乱
