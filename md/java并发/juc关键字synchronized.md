####  juc关键字 synchronized ThreadLocal  volatile

## synchronized

    可以保证方法或者代码块在运行时，同一时刻只有一个方法可以进入到临界区，同时它还可以保证共享变量的内存可见性

#### Java对象头和monitor


#### jdk1.6 优化 synchronized 

自旋锁 

    线程的阻塞和唤醒需要CPU从用户态转为核心态 自旋锁就是让该线程A等待一段时间，不会被立即挂起，
    看持有锁的线程B是否会很快释放锁。怎么等待呢？线程A执行一段无意义的循环即可（自旋） 
    如果自旋超过了定义的时间仍然没有获取到锁，则线程A应该被挂起

适应自旋锁

    意味着自旋的次数不再是固定的，它是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定

锁消除

锁粗化

偏向锁获取锁
    
    1. 检测Mark Word是否为可偏向状态，即是否为偏向锁1，锁标识位为01；
    2. 若为可偏向状态，则测试线程ID是否为当前线程ID，如果是，则执行步骤（5），否则执行步骤（3）；
    3. 如果线程ID不为当前线程ID，则通过CAS操作竞争锁，竞争成功，则将Mark Word的线程ID替换为当前线程ID，否则执行线程（4）；
    4. 通过CAS竞争锁失败，证明当前存在多线程竞争情况，当到达全局安全点，获得偏向锁的线程被挂起，
        偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码块；
    5. 执行同步代码块

偏向锁释放锁

    1. 暂停拥有偏向锁的线程，判断锁对象石是否还处于被锁定状态；
    2. 撤销偏向苏，恢复到无锁状态（01）或者轻量级锁的状态；

轻量级锁获取锁
    
    1. 判断当前对象是否处于无锁状态（hashcode、0、01），若是，则JVM首先将在当前线程的栈帧中
        建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝
        （官方把这份拷贝加了一个Displaced前缀，即Displaced Mark Word）；否则执行步骤（3）；
    
    2. JVM利用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指正，如果成功表示竞争到锁
        则将锁标志位变成00（表示此对象处于轻量级锁状态），执行同步操作；如果失败则执行步骤（3）；
    
    3. 判断当前对象的Mark Word是否指向当前线程的栈帧，如果是则表示当前线程已经持有当前对象的锁，
        则直接执行同步代码块；否则只能说明该锁对象已经被其他线程抢占了，这时轻量级锁需要膨胀为重量级锁，
        锁标志位变成10，后面等待的线程将会进入阻塞状态；

轻量级锁释放锁

    1. 取出在获取轻量级锁保存在Displaced Mark Word中的数据；
    
    2. 用CAS操作将取出的数据替换当前对象的Mark Word中，如果成功，则说明释放锁成功，否则执行（3）
    
    3. 如果CAS操作替换失败，说明有其他线程尝试获取该锁，则需要在释放锁的同时需要唤醒被挂起的线程。
    
重量级锁

    重量级锁通过对象内部的监视器（monitor）实现，其中monitor的本质是依赖于底层操作系统的Mutex Lock
    实现，操作系统实现线程之间的切换需要从用户态到内核态的切换，切换成本非常高。


##### Java中每一个对象都可以作为锁，这是synchronized实现同步的基础：

    1 普通同步方法，锁是当前实例对象
    2 静态同步方法，锁是当前类的class对象
    3 同步方法块，锁是括号里面的对象


synchronized 作用
    
    1   确保线程互斥访问同步代码
    2   保证共享变量的修改能够及时可见
    3   有效解决重排序的问题
    
synchronized 通过 monitor 和 monitorexit 对象 （指令）来控制访问同步

## ThreadLocal 

    1   ThreadLocal的内部类ThreadLocalMap（weakreference 虚引用） 维护线程中的变量
    2   ThreadLocal 会为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突
    
